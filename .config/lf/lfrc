# **TEMPLATES**

# APP=$(command -v app)
# if [[ -z $APP ]]; then
#     lf -remote "send $id echoerr app is not installed."
# fi

%[ $LF_LEVEL -eq 1 ] || printf "Warning: You're in a nested lf instance!"

set anchorfind true
set autoquit true
set findlen 4
set incsearch true
set incfilter true
set icons true
set shell bash
set mouse true
set preview false
set selmode dir
set hidden true
# set filesep "\n"

# Right now this looks useless.
# It is this that causes the below error message when you exit lf.
# listen: send: no such client id is connected
# cmd recol %{{
#     w=$(tput cols)
#     if [ $w -le 80 ]; then
#         lf -remote "send $id set ratios 1:2"
#     elif [ $w -le 160 ]; then
#         lf -remote "send $id set ratios 1:2:3"
#     else
#         lf -remote "send $id set ratios 1:2:3:5"
#     fi
# }}

# Info: Noop>on-cd
cmd on-cd &{{
    printf "\033]0;lf - $PWD\007" > /dev/tty
}}

# Invoke rename command with F2
map <f-2> :rename

# Reload
map <f-5> :reload

map <f-4> :filter
# set previewer /usr/local/bin/pistol
# set previewer ~/.config/ranger/scope.sh

# Disabled preview and use i key for previewing
# set nopreview
# map i $/usr/local/bin/pistol $f | less -R
map i !{{
    # if [[ -f "$f" ]]; then
    #     BAT_PAGER='less -R --incsearch -i -J -g' $(command -v bat) "$f"
    # else
    #     lf -remote "send $id echoerr Previewer only works on files!"
    # fi
    # clear && /usr/local/bin/pistol "$f" | less -R --incsearch -i -J -g

    # if [[ $TERM == "xterm-kitty" ]]; then
    #     if [[ -S /tmp/mykitty ]]; then
    #         kitty @ --to unix:/tmp/mykitty launch \
    #             --keep-focus --type=overlay-main \
    #             --hold $PISTOL "$f"
    #             # since kitty v29, --hold drops to a command prompt.
    #     fi
    # else
    #     clear && $PISTOL "$f"
    # fi

    mime=$(file --brief --mime "${f}")
    if [[ $mime =~ ^application/json ]]; then
        FX_COLLAPSED=1 $(command -v fx) "${f}"
        exit 0
    fi

    if [[ $mime == text/* ]]; then

        ext="${f##*.}"
        if [[ $ext == "md" ]]; then
            GLOW=$(command -v glow)
            PAGER="/usr/bin/bat --style plain" "${GLOW}" --pager --config "${HOME}/.config/glow/glow.yml" "${f}"
            exit 0
        fi

        clear;/usr/local/bin/vim -u "${HOME}/.vim/vimrc.minimal" "${f}"
        exit 0
    fi

    PISTOL=$(command -v pistol)
    if [[ -z $PISTOL ]]; then
        lf -remote "send $id echoerr pistol is not installed."
        exit
    fi
    clear && /usr/local/bin/pistol "$f"

}}

# Info: Open current working directory in GUI file manager
cmd open-in-file-manager &{{
    DOLPHIN=$(command -v dolphin)
    if [[ -n $DOLPHIN ]]; then
        $DOLPHIN --select "${f}"
    else
        xdg-open "${PWD}"
    fi
}}
map <c-o> :open-in-file-manager

# Info: Open selected file with the associated application <O>
cmd open-with-menu !{{
    # Requires libfile-mimeinfo-perl package
    clear
    open-with.pl "${f}"
}}
map O :open-with-menu

# Info: Make selection executable <+x>
cmd make-selection-executable &{{
    # Make selection executable
    list=""
    while IFS=$'\n' read item; do
        if [[ -f "${item}" ]] && [[ ! -x "${item}" ]]; then
            list+="${item}\n"
        fi
    done < <(printf "${fx}\n")
    printf "$list" | xargs --delimiter='\n' chmod +x
    lf -remote "send $id reload"
}}
map +x :make-selection-executable
# map +x &{{
#     lf -remote "send $id make-selection-executable"
# }}

# Info: Remove executable bit from selection <-x>
cmd make-selection-nonexecutable &{{
    list=""
    while IFS=$'\n' read item; do
        if [[ -f "${item}" ]] && [[ -x "${item}" ]]; then
            list+="${item}\n"
        fi
    done < <(printf "${fx}\n")
    printf "$list" | xargs --delimiter='\n' chmod -x
    lf -remote "send $id reload"
}}
map -x :make-selection-nonexecutable
# map -x &{{
#     lf -remote "send $id make-selection-nonexecutable"
# }}

# Another command based version
# cmd open &xdg-open $f

# map U $ncdu $f

# cli, not tui, so needs screen clearing.
# Horizontal bar charts, but can be disabled.
# Does not support selection and deletion as in ncdu and gdu.
# map U !dust $f

# This feels fast. Written in Rust.
# Can output in json.
# Horizontal bar chart.
# Can display all items, not just big ones with --min-ratio=0
# Info: Display size of the selected item(s) <U>
cmd size-usage !{{
    PDU=$(command -v pdu)
    if [[ -n $PDU ]]; then
        # clear && echo -ne "Calculating... \r"
        clear && printf "Calculating... \r"
        printf "$fx" | xargs --delimiter='\n' $PDU --bytes-format=binary
    else
        lf -remote "send $id echoerr pdu is not installed."
    fi
}}
map U :size-usage
# map U &{{
#     lf -remote "send $id size-usage"
# }}

# This may be the one you'll want to use.
# It is the go port of ncdu, but colorized.
# This can return the selected item if Q is pressed.
# map U $gdu $f

# This is only interested in finding large files.
# When directory is small, it doesn't even show the total size.
# Can output selected large files to external tools.
# map U $godu $f

# According to pdu, this is the slowest one.
# But doesn't feel slow though.
# No progress bar for large directories.
# Displays apparant size with a cli flag.
# map U $dua interactive $f

# Below is not working.
# map <enter> :select $f

# Creating custom command
# cmd usage $du -h -d1 | less
# Can chain commands
# map st :set sortby time; set info time

# Info: Create a drag and drop source with dragon
cmd dnd &{{
    DRAGON=$(command -v dragon-drag-and-drop)
    if [[ -z $DRAGON ]]; then
        lf -remote "send $id echoerr dragon is not installed."
    fi
    printf "${fx}" | xargs --delimiter='\n' $DRAGON --and-exit -on-top --all
}}

# Info: Convert current working directory to a dnd drop target
cmd drop ${{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi
    DRAGON=$(command -v dragon-drag-and-drop)
    if [[ -z $DRAGON ]]; then
        lf -remote "send $id echoerr dragon is not installed."
    fi

    items=$($DRAGON --target --and-exit -p)
    if [[ -n $items ]]; then
        res=$(printf "Copy\nMove" | $FZF --no-info --disabled --no-multi --cycle -q "Select action...")

        if [[ $res == "Copy" ]]; then
            printf "${items}" | xargs --delimiter='\n' cp -R --update --target-directory="${PWD}"
        elif [[ $res == "Move" ]]; then
            printf "${items}" | xargs --delimiter='\n' mv --update --target-directory="${PWD}"
        fi

        if [[ -n $res ]]; then
            lf -remote "send $id load"
        fi
    fi
}}


# Info: Autojump to directory <gj>
cmd j &{{
    J=$(command -v autojump)
    if [[ -z $J ]]; then
        lf -remote "send $id echoerr autojump is not installed."
    fi
    lf -remote "send $id cd $($J $@)"
}}
map gj &{{
    lf -remote "send $id push :j<space>"
}}

# Info: FZF integration using <c-f>
cmd fzf-jump ${{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    FD=$(command -v fd)
    if [[ -z $FD ]]; then
        lf -remote "send $id echoerr fd is not installed."
    fi

    # NOTE: In order to make fd ignore items in gitignore files,
    # it must contain a .git directory.
    res="$(fd --exclude '.git' -H --ignore | $FZF +m --header='Jump to location' | sed 's/\\/\\\\/g;s/"/\\"/g')"

    if [[ -z "${res}" ]]; then
        exit 0
    fi

    if [[ -d "${res}" ]]; then
        cmd="cd"
    elif [[ -f "${res}" ]] ; then
        cmd="select"
    else
        exit 0
    fi

    if [[ -n $res ]]; then
        lf -remote "send $id $cmd \"$res\""
    fi
}}
map <c-f> :fzf-jump

# Info: Grep files using fzf and ripgrep
cmd grep ${{
    # This version is not capable of fuzzy search, use grepf instead
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi
    res="$( \
        RG_PREFIX="rg --hidden --column --line-number --no-heading --color=always \
            --smart-case --no-hidden "
        FZF_DEFAULT_COMMAND="$RG_PREFIX ''" \
            $FZF --bind "change:reload:$RG_PREFIX {q} || true" \
            --ansi --header 'Search in files' \
            | cut -d':' -f1-2
    )"
    # Read FZF response into $file and $line
    IFS=":" read -rd '' file line < <(printf '%s%s' "${res}" ":") || true
    [ ! -z "${file}" ] && lf -remote "send $id select \"$file\""
    # FIXME: not works for neovim
    # DON'T run the editor if lf is inside VIM or nvim
    # pid=$(pgrep -f '^sh -c lf')
    # if [[ -z "${pid}" ]]; then
    #     vim +"${line}" "${file}"
    # fi
}}

# Info: Fuzzy grep files using fzf and ripgrep
cmd grepf ${{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    # TODO: Limit fuzzy search to line content
    res="$(rg --hidden --column --color=always --line-number --no-heading --smart-case "${*:-}" |
        $FZF --ansi \
        --color "hl:-1:underline,hl+:-1:underline:reverse" \
        --delimiter : \
        | cut -d':' -f1-2
        )"
    # echo "${res}"
    IFS=":" read -rd '' file line < <(printf '%s%s' "${res}" ":") || true
    [ ! -z "${file}" ] && lf -remote "send $id select \"$file\""
    # FIXME: not works for neovim
    # DON'T run the editor if lf is inside VIM or nvim
    # pid=$(pgrep -f '^sh -c lf')
    # if [[ -z "${pid}" ]]; then
    #     vim +"${line}" "${file}"
    # fi
}}

# Info: Create new directory
cmd mkdir %{{
    if [[ -z "$@" ]]; then
        lf -remote "send $id echoerr No arguments provided"
        exit
    fi

    if [[ -w "${PWD}" ]]; then
      mkdir -p -- "$@"
      lf -remote "send $id select ${PWD}/$@"
    else
        lf -remote "send $id echoerr Current working directory is not writable."
    fi

}}

# Info: Create new file
cmd touch %{{
    if [[ -z "$@" ]]; then
        lf -remote "send $id echoerr No arguments provided"
        exit
    fi

    if [[ -w "${PWD}" ]]; then
      touch "$@"
      lf -remote "send $id select \"${@}\""
    else
      lf -remote "send $id echoerr Current working directory is not writable."
    fi
}}

# Info: Create new directory or file
cmd new !{{
    clear
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    res=$(printf "Directory\nFile" | $FZF)
    case "${res}" in
        File)
            printf "New file name: "
            read newf
            if [[ -n "${newf}" ]]; then
                lf -remote "send $id touch \"${newf}\""
            fi
            ;;
        Directory)
            printf "New directory name: "
            read newd
            if [[ -n "${newd}" ]]; then
                lf -remote "send $id mkdir \"${newd}\""
            fi
            ;;
        *)
            lf -remote "send $id echoerr Unknown action."
    esac
}}

# Info: Move selected item(s) to the directory that will be created
cmd move2newdir ${{
    clear
    set -f
    printf "Directory name: "
    read newd
    mkdir -p -- "$newd"
    # TODO: this cannot handle items with spaces
    mv -- "${fx}" "$newd"
    lf -remote "send $id select \"${newd}\""
}}

# Info: Create symlinks(y)/hardlinks(d) then <P> to create
cmd link %{{
    # y (select for copy) and P to paste soft-link
    # d (select for cut) and P to paste hard-link

    # This converts the contents of the file into script arguments
    set -- $(cat ~/.local/share/lf/files)
    mode="$1"
    shift # Rest is the list of file to be linked.
    if [ "$#" -lt 1 ]; then
        # lf -remote "send $id echoerr First select the item to be linked to by pressing y(soft link) or d(hard link)."
        exit 0
    fi
    case "$mode" in
        # # symbolically copy mode is indicating a soft link
        # copy) ln -sr -t . -- "$@";;
        # # while a move mode is indicating a hard link
        # move) ln -t . -- "$@";;

        # symbolically copy mode is indicating a soft link
        copy)
            # ln -sr -t . -- "$@";;
            for i in "$@"; do
                file="$(basename "${i}")"
                if [[ ! -f "./${file}" ]]; then
                    ln -sr -t . -- "$i"
                else
                    # we are in the same directory as the target
                    ln -sr  "${i}" "./${file}.soft"
                fi
            done
            ;;
        # while a move mode is indicating a hard link
        move)
            # ln -t . -- "$@";;
            for i in "$@"; do
                file="$(basename "${i}")"
                if [[ ! -f "./${file}" ]]; then
                    ln -t . -- "$i"
                else
                    # we are in the same directory as the target
                    ln "${i}" "./${file}.hard"
                fi
            done
            ;;
    esac
    rm ~/.local/share/lf/files
    lf -remote "send $id clear"
}}
map P :link

# Info: Go to a bookmarked directory <b>
cmd bookmark-jump ${{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi
    LF_BOOKMARK_PATH="$HOME/.config/lf/bookmarks"
    res=$(cat $LF_BOOKMARK_PATH/$(ls "$LF_BOOKMARK_PATH" | $FZF))
    # Bookmarks file contains shell variables.
    # So this was the first thing that came to my mind.
    res=$(eval "echo -e ${res}")

    if [[ -z "${res}" ]]; then
        exit
    fi

    # echo "${res}"

    if [[ -d "${res}" ]]; then
        lf -remote "send $id cd \"${res}\""
    else
        lf -remote "send $id echoerr Err: Target directory does not exist."
    fi
}}
map b :bookmark-jump

# Info: Bookmark the working directory ( not the selected one ) <B>
cmd bookmark-create ${{
    LF_BOOKMARK_PATH="$HOME/.config/lf/bookmarks"
    clear
    read -rp "Enter the bookmark name for ${PWD}: " ans
    if [[ -n "${ans}" ]]; then
        if [[ "$PWD" == ${HOME}* ]]; then
            current=${PWD/#${HOME}/\$HOME}
            printf "${current}" > "${LF_BOOKMARK_PATH}/${ans}"
        elif [[ "$PWD" == /media/${USER}* ]]; then
            current=${PWD//${USER}/\$USER}
            printf "${current}" > "${LF_BOOKMARK_PATH}/${ans}"
        else
            printf "${PWD}" > "${LF_BOOKMARK_PATH}/${ans}"
        fi
    fi
}}
map B :bookmark-create

# TODO: handles flatpaks but not snaps
# Info: Open selected file with a manually entered application
cmd open-with &{{
    if [[ -z "$@" ]]; then
        lf -remote "send $id echoerr Err: Enter an application name."
    fi
    APP=$(command -v "$@")
    if [[ -n "${APP}" ]]; then
        "${APP}" "${fx}"
    else
        ISFLATPAK=$(flatpak list --app --columns=application | grep -i "$@")
        if [[ -n "$ISFLATPAK" ]]; then
            flatpak run "${ISFLATPAK}" "${fx}"
        else
            lf -remote "send $id echoerr Err: Application could not be found in PATH."
        fi
    fi
}}
map ` push :open-with<space>

# Info: Quicklook single image with sxiv <gq>
cmd quicklook-single-image &{{
    iv=$(command -v nsxiv)

    if [[ -z $iv ]]; then
        iv=$(command -v sxiv)
        if [[ -z $iv ]]; then
            lf -remote "send $id echoerr Err: Neither nsxiv nor sxiv is installed."
            exit
        fi
    fi

    # if [[ -d "$f" ]]; then
    #     items=$($iv -o -t -p "$f")
    # fi

   printf "${fx}" | xargs --delimiter='\n' $iv

    # if [[ -n $items ]]; then
    #     items=$(wrap-with-quotes "${items}")
    #     lf -remote "send $id toggle $(echo ${items})"
    # fi
}}
map gq :quicklook-single-image

# What you mark in sxiv will also be selected in lf.
# Info: View current directory in thumbnail mode <gb>
cmd browse-images &{{
    iv=$(command -v nsxiv)

    if [[ -z $iv ]]; then
        iv=$(command -v sxiv)
        if [[ -z $iv ]]; then
            lf -remote "send $id echoerr Err: Neither nsxiv nor sxiv is installed."
            exit
        fi
    fi

    if [[ -d "$f" ]]; then
        items=$($iv -o -t -p "$f")
    fi

    if [[ -f "$f" ]]; then
        items=$($iv -o -t -p "$(dirname "$item")")
    fi

    if [[ -n $items ]]; then
        items=$(wrap-with-quotes "${items}")
        lf -remote "send $id toggle $(echo ${items})"
    fi
}}
map gb :browse-images

# Info: Create archive using atool <gz>
cmd archive &{{
    APACK=$(command -v apack)

    if [[ -z $APACK ]]; then
        lf -remote "send $id echoerr atool package is not installed."
        exit
    fi

    if [[ -z "$@" ]]; then
        lf -remote "send $id echoerr Usage: archive output.[tar].[gz|bz|bz2|lzo|lz|xz|7z|zip|rar]"
        exit
    fi

    printf "${fx}" | xargs --delimiter='\n' realpath --relative-to="$PWD" | xargs --delimiter='\n' $APACK "$@"
    if [[ -f "$@" ]]; then
        lf -remote "send $id load"
        lf -remote "send $id echo $@ created."
    fi
}}
map gz push :archive<space>

# Info: Extract archive with atool
cmd extract !{{
    AUNPACK=$(command -v aunpack)

    if [[ -z $AUNPACK ]]; then
        lf -remote "send $id echoerr atool package is not installed."
        exit
    fi

    # TODO: Select the extracted item
    ( $AUNPACK "$f" && lf -remote "send $id load" ) || lf -remote "send $id echoerr Archive could not be extracted."

}}

# Info: Copy selected file paths to clipboard
cmd path &{{
    if [[ $XDG_SESSION_TYPE == 'x11' ]]; then
        XCLIP=$(command -v xclip)
        if [[ -z $XCLIP ]]; then
            lf -remote "send $id echoerr xclip is not installed."
            exit
        fi

        xclip -sel clip < <(printf "${fx}") && \
            lf -remote "send $id echo Paths copied to the clipboard."
    else
        lf -remote "send $id echoerr You are probably in a Wayland session."
    fi
}}

# Info: Copy parent directory path to clipboard
cmd dirname &{{
    if [[ $XDG_SESSION_TYPE == 'x11' ]]; then
        XCLIP=$(command -v xclip)
        if [[ -z $XCLIP ]]; then
            lf -remote "send $id echoerr xclip is not installed."
            exit
        fi

        xclip -sel clip < <(dirname "${f}") && \
            lf -remote "send $id echo Parent directory names copied to the clipboard."
    else
        lf -remote "send $id echoerr You are probably in a Wayland session."
    fi
}}

# Info: Copy filenames to clipboard
cmd basename &{{
    if [[ $XDG_SESSION_TYPE == 'x11' ]]; then
        XCLIP=$(command -v xclip)
        if [[ -z $XCLIP ]]; then
            lf -remote "send $id echoerr xclip is not installed."
            exit
        fi

        xclip -sel clip < <(printf "${fx}" | xargs --delimiter='\n' -I '{}' basename '{}') && \
            lf -remote "send $id echo File names copied to the clipboard."
    else
        lf -remote "send $id echoerr You are probably in a Wayland session."
    fi
}}

# Info: Slideshow with feh image viewer <gs> <gr>
cmd slideshow &{{
    FEH=$(command -v feh)
    if [[ -z $FEH ]]; then
        lf -remote "send $id echoerr feh - image viewer is not installed."
    fi

    if [[ $@ == "recursive" ]]; then
        r="--recursive"
    fi

    if [[ -f "$f" ]]; then
        target=$(dirname "$f")
    elif [[ -d "$f" ]]; then
        target="$f"
    fi

    $FEH -q "$r" --on-last-slide resume \
        --scale-down --slideshow-delay 4 \
        --randomize --quite --image-bg black "$target"

    if [[ $? != 0 ]]; then
        lf -remote "send $id echoerr There are no loadable images."
    fi
}}
map gs :slideshow
map gr :slideshow recursive

# Info: Play current directory as a playlist with VLC <gv>
cmd playvideos &{{
    VLC=$(command -v vlc)
    if [[ -z $VLC ]]; then
        lf -remote "send $id echoerr VLC player is not installed."
    fi

    if [[ $@ == "recursive" ]]; then
        r='--recursive expand'
    fi

    if [[ -f "$f" ]]; then
        target=$(dirname "$f")
    elif [[ -d "$f" ]]; then
        target="$f"
    fi

    $VLC $r --quiet --random --qt-minimal-view "${target}"

    if [[ $? != 0 ]]; then
        lf -remote "send $id echoerr There are no loadable videos."
    fi
}}
map gv :playvideos recursive

# Info: Start image and video presentation from /media
cmd st &{{
    # Running lf with -command that does '-remote send' sometimes not work
    # So we are sleeping for a while...
    # /run/user/1000/lf.${USER}.sock
    sleep 1

    mounted=$(fd . /media/"${USER}"/ -d1)

    # We expect to find media only in container directories
    # not also in storage devices those are under /media/user.
    if [[ -n $mounted ]]; then
        lf -remote "send $id echoerr Other storage devices are mounted!"
        exit 1
    fi

    lf -remote "send $id select /media"
    lf -remote "send $id push gr"
    lf -remote "send $id push gv"

    amixer -q sset 'Master' 0%
    # pactl -- set-sink-volume 0 0%

    for window in $(wmctrl -l); do
        wid=$(printf ${window} | cut -d" " -f1)
        xdotool key --window "${wid}" "super+Page_Down"
    done

    vlcid=$(wmctrl -l | grep "VLC media player" | cut -d" " -f1)
    fehid=$(wmctrl -l | grep feh | cut -d" " -f1)

    se=$(command -v safeeyes)
    if [[ -n "${se}" ]]; then
        $se -d
    fi

    xdotool windowactivate "${fehid}"
    xdotool windowactivate "${vlcid}"
}}

# Only useful for encrypted text files
# that will be printed to the screen.
# Info: Decrypt file which is encrypted with gpg
cmd decrypt !{{
    clear
    gpg -qd --pinentry-mode loopback "${f}"
    printf "\n"
}}

# Info: Provide basic encryption/decryption with gpg
cmd gpg !{{
    clear
    # gpg -qd --pinentry-mode loopback "$f"
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    res=$(
        printf "a: Encrypt with private key\n\
b: Encrypt with passphrase\n\
c: Decrypt\n\
        " \
        | $FZF --no-info --disabled --no-multi --cycle -q "Select action...")

    res=$(printf "${res}" | cut -d':' -f1)

    if [[ -z "${res}" ]]; then
        exit
    fi

    case "${res}" in
    a)
        publickey=$(gpg --list-keys --with-colons | grep uid | cut -d':' -f10 \
            | $FZF --no-info --disabled --no-multi --cycle -q "Select public key...")

        if [[ -f "$f" ]]; then
            filename="$(basename "$f").gpg"

            if [[ -n "${publickey}" ]]; then
                gpg --output "${filename}" --encrypt --recipient "${publickey}" "$f"
                if [[ -f "${filename}" ]]; then
                    lf -remote "send $id select \"${filename}\""
                fi
            fi

        elif [[ -d "$f" ]]; then
            APACK=$(command -v apack)
            archive_name="$(basename "$f").tar"
            filename="${archive_name}.gpg"
            $APACK "${archive_name}" $(realpath --relative-to="${PWD}" "${f}")
            if [[ -f "${archive_name}" ]]; then
                gpg --output "${filename}" --encrypt --recipient "${publickey}" "${archive_name}"
                if [[ -f "${filename}" ]]; then
                    rm -f "${archive_name}"
                    lf -remote "send $id select \"${filename}\""
                fi
            fi
        fi
        ;;
    b)
        if [[ -f "${f}" ]]; then
            filename="$(basename "$f").gpg"
            gpg --pinentry-mode loopback --output "${filename}" --symmetric "$f"
            if [[ -f "${filename}" ]]; then
                lf -remote "send $id select \"${filename}\""
            fi
        elif [[ -d "$f" ]]; then
            APACK=$(command -v apack)
            archive_name="$(basename "$f").tar"
            filename="${archive_name}.gpg"
            $APACK "${archive_name}" $(realpath --relative-to="${PWD}" "${f}")
            if [[ -f "${archive_name}" ]]; then
                gpg --pinentry-mode loopback --output "${filename}" --symmetric "${archive_name}"
                if [[ -f "${filename}" ]]; then
                    rm -f "${archive_name}"
                    lf -remote "send $id select \"${filename}\""
                fi
            fi
        fi
        ;;
    c)
        action=$(printf "a: Write to file\nb: Print to the screen (Be careful with binary files)" \
            | $FZF --no-info --disabled --no-multi --cycle -q "Select action...")
        action=$(printf "${action}" | cut -d':' -f1)

        if [[ -n "${action}" ]]; then
            case "${action}" in
            a)
                clear
                read -rp "Enter a name for the output file: " ans
                if [[ -f "${ans}" ]]; then
                    ans="${ans}.new"
                fi
                gpg -qd --pinentry-mode loopback "${f}" > "${ans}"
                if [[ -f "${ans}" ]]; then
                    lf -remote "send $id select \"${ans}\""
                fi
                ;;
            b)
                clear
                gpg -qd --pinentry-mode loopback "${f}"
                ;;
            *)
                printf "You did not specify a choice.\n"
                exit
            esac

        fi
        ;;
    *)
        printf "You did not specify a choice.\n"
        exit
    esac
}}

map <delete> delete

# Info: Trash selected items to ~/.local/share/Trash without actually deleting
cmd trash &{{
    wrap-with-quotes "${fx}" | xargs -I '{}' rip --graveyard ~/.local/share/Trash/rip "{}"
    lf -remote "send $id load"
}}

# Info: Empty the trash located in ~/.local/share/Trash
cmd empty-trash !{{
    rip --decompose --graveyard ~/.local/share/Trash/rip
    lf -remote "send $id load"
}}

# Info: Restore item from Trash
cmd untrash &{{
    wrap-with-quotes "${fx}" | xargs -I '{}' rip --unbury "{}" --graveyard ~/.local/share/Trash/rip
    lf -remote "send $id load"
}}

# Info: Check if selected directory is in a backup profile or not
cmd in-backup-profile %{{
    in-backup-profile.sh "${f}"
}}

# Info: Select items in cwd which are not listed in a backup profile
cmd not-in-backup-profile &{{
    lf -remote "send $id echo Please wait..."
    dirs=$(find ./* -maxdepth 0)
    items=()

    for item in ${dirs}; do
        out=$(in-backup-profile.sh "${item}")
        if [[ $out == No* ]]; then
            # lf -remote "send $id select ${item}"
            items+=("${item}")
        fi
    done

    lf -remote "send $id echo ''"
    if [[ ${#items[@]} -gt 0 ]]; then
        # TODO: wrap-with-quotes
        lf -remote "send $id toggle $(echo ${items[@]})"
    fi
}}

# Info: Slugify filenames using mkslug script
cmd slugify &{{
    # TODO: PERL candidate
    while IFS=$'\n' read item
    do
        parent="$(dirname "${item}")"
        base="$(basename "${item}")"

        fixed=$(mkslug "${base}")
        if [[ "$fixed" != "$base" ]]; then
            mv "${parent}/${base}" "${parent}/${fixed}"
        fi
    done < <(printf "${fx}\n")
    lf -remote "send $id load"
}}

# Info: Add selected item to an existing rustic backup profile
cmd add-to-backup-profile ${{
    RSTC=$(command -v rstc)
    if [[ -z $RSTC ]]; then
        lf -remote "send $id echoerr rstc script is not installed."
    fi

    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    FD=$(command -v fd)
    if [[ -z $FD ]]; then
        lf -remote "send $id echoerr fd is not installed."
    fi

    res="$($FD toml --base-directory ~/.config/rustic -x printf "{/.}\n" | sed '$s/$/\nCreate a new profile.../' | $FZF +m --header='Select backup profile')"

    if [[ -n "${res}" ]]; then
        if [[ $res =~ ^Create ]]; then
            read -rp "Enter the new profile name: " ans
            if [[ -z "${ans}" ]]; then
                lf -remote "send $id echoerr You did not specify a profile name!"
                exit
            fi

            if [[ -n "${ans}" ]]; then
                if [[ -f "${HOME}/.config/rustic/${ans}.toml" ]]; then
                    lf -remote "send $id echoerr Profile already exists!"
                    exit
                else
                    rstc create "${ans}"
                    if [[ -f "${HOME}/.config/rustic/${ans}.toml" ]]; then
                        res="${ans}"
                    else
                        lf -remote "send $id echoerr Profile could not be created!"
                        exit
                    fi
                fi
            fi
        fi

        while IFS=$'\n' read item
        do
            check=$(grep "\"${item}\"" "${HOME}/.config/rustic/${res}.toml")

            if [[ -z $check ]]; then
                cat <<EOT >> "${HOME}/.config/rustic/${res}.toml"

[[backup.sources]]
source = "${item}"
EOT
            fi
        done < <(printf "${fx}\n")
    fi
}}

# Info: Restore selected backup profile to a destination of your choice
cmd restore-backup ${{
    # TODO: Not implemented yet.
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    FD=$(command -v fd)
    if [[ -z $FD ]]; then
        lf -remote "send $id echoerr fd is not installed."
    fi

    res="$($FD toml --base-directory ~/.config/rustic -x printf "{/.}\n" | $FZF +m --header='Select backup profile to restore')"

    if [[ -f "${HOME}/.config/rustic/${res}.toml" ]]; then
        lf -remote "send $id echo You selected $res"
    fi

}}

# Info: Go to the most recent file in current directory
cmd last &{{
    # This function accepts a directory as argument.
    # If it is not provided, than CWD is used.
    FD=$(command -v fd)
    ITEM=$(
        $FD --base-directory "${@:-./}" --exact-depth 1 \
            --type f -a \
            --color never --exec-batch ls -t -Q -1 | head -n1
    )
    if [[ -n $ITEM ]]; then
        lf -remote "send $id select ${ITEM}"
    fi
}}

# Info: Go to the most recently downloaded item in ~/Downloads
cmd lastdown &{{
    lf -remote "send $id :last \"${HOME}/Downloads\""
}}

# Info: Mount veracrypt container
cmd mountc !{{
  clear
  if [[ ! -f /etc/.container.gpg ]]; then
    lf -remote "send $id echoerr '/etc/.container.gpg' file does not exist. Use 'enc' function to create it."
    exit
  fi

  pass=$(gpg -q -d --pinentry-mode loopback /etc/.container.gpg)

  while IFS=$'\n' read item; do
    BASENAME=$(basename "${item}")
    SLOT=$(echo "${BASENAME%%.*}" | cut -d'_' -f2)

    sudo conta --text --fs-options=umask=022 --non-interactive --mount --slot="${SLOT}" --password="${pass}" "${item}"

    output=$(conta --text --non-interactive --volume-properties "${item}")
    mpoint=$(printf "${output}" | grep "Mount Directory" | cut -d' ' -f3)
    if [[ -d $mpoint ]]; then
      printf "Successfully mounted: ${mpoint}\n"
    else
      printf "Could not mount one of the selected files...\n"
    fi
  done < <(printf "${fx}\n")
}}

# Info: Go to the mount point of the selected veracrypt container
cmd goto-container-mount-point &{{
    output=$(conta --text --non-interactive --volume-properties "$f")
    mpoint=$(printf "${output}" | grep "Mount Directory" | cut -d' ' -f3)
    if [[ -d $mpoint ]]; then
      lf -remote "send $id select \"${mpoint}\""
    else
        lf -remote "send $id echoerr This item is not mounted..."
    fi
}}

# Info: Mount iso image
cmd mount-iso !{{
  clear
  mime=$(mimetype --output-format '%m' "${f}")

  if [[ "${mime}" =~ x-cd-image$ ]]; then
      mpoint=$(mkslug $(basename "${f}"))

      if [[ ! -d "/tmp/${mpoint}" ]]; then
          mkdir "/tmp/${mpoint}"
      fi

      if [[ -z "$(ls -A "/tmp/${mpoint}")" ]]; then
          sudo mount -o loop "${f}" "/tmp/${mpoint}"
          lf -remote "send $id cd "/tmp/${mpoint}""
      else
          lf -remote "send $id echoerr Mount directory "/tmp/${mpoint}" is not empty!"
      fi
  else
      lf -remote "send $id echoerr Not an image file!"
      exit
  fi
}}

# Info: Unmount iso image or mount point
cmd umountiso !{{
  # TODO: Use fzf to select mount points
  clear

  if [[ -n $(mount | grep "${f}") ]]; then
      mpoint=$(mkslug $(basename "${f}"))

      if [[ -z "${mpoint}" ]]; then
          exit
      fi

      sudo umount "${mpoint}"

      if [[ -d "/tmp/${mpoint}" ]] && [[ -z "$(ls -A "/tmp/${mpoint}")" ]]; then
          lf -remote "send $id cd ~"
          rmdir "/tmp/${mpoint}"
      fi
      exit
  fi
}}

# Info: Batch rename items in current directory using vimv
cmd batch-rename !{{
    clear
    # This is the vimv script source
    # https://github.com/thameera/vimv
    VIMV=$(command -v vimv)
    if [[ -z $VIMV ]]; then
        lf -remote "send $id echoerr vimv is not installed."
        exit
    fi

    $VIMV
}}

# Info: Unmount veracrypt container
cmd umountc !{{
    clear
    while IFS=$'\n' read item; do
        sudo conta --text --non-interactive --dismount "${item}"
    done < <(printf "${fx}\n")
}}

# Info: Unmount USB drives mounted to /media/${USER}
cmd umount-usb !{{
    clear
    # fd -t d . "/media/${USER}" -d1
    # fd adds trailing slash
    storages=$(find /media/"${USER}"/* -maxdepth 0 -type d 2>/dev/null)

    if [[ -z ${storages} ]]; then
        lf -remote "send $id echoerr No external storage attached to the system!"
        exit
    fi

    storage=$(printf '%s' "${storages}" | fzf)
    if [[ -d "${storage}" ]]; then
        device=$(mount | grep "$storage" | cut -c 1-8)
        mapfile -t AllPartitions < <(mount | grep "$device" | cut -c 1-9)

        # There may be multiple partitions of a storage
        for i in "${AllPartitions[@]}"; do
            udisksctl unmount -b "$i"
        done
        # Power off the related storage
        udisksctl power-off -b "${device}"
    fi
}}

# Info: Share selected files using kdeconnect-cli
cmd kshare !{{
  clear
  FZF=$(command -v fzf)
  if [[ -z $FZF ]]; then
      lf -remote "send $id echoerr fzf is not installed."
  fi

  res=$(kdeconnect-cli -a --name-only | $FZF --no-info --disabled --no-multi --cycle -q "Select device...")

  if [[ -n $res ]]; then
    printf "${fx}" | xargs --delimiter='\n' kdeconnect-cli -n "${res}" --share
  fi
}}

# Usage: :run or :runs for sudo
# Info: Run any executable in a new kitty window <go>
cmd run &{{
    if [[ -x "${f}" ]]; then
        # --type=overlay
        kitty @ --to unix:/tmp/mykitty launch --cwd "${PWD}" --self "${@:+sudo}" "${f}"
    else
        lf -remote "send $id echoerr Item is not executable."
    fi
}}
map go :run

# Info: Run command with sudo <gO>
cmd runs &{{
    lf -remote "send $id :run s"
}}
map gO :runs

# Info: Basic image operations using GraphicsMagick and ffmpeg
cmd gm !{{
    clear
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    # Main menu
    res=$(
cat <<EOF | $FZF
Convert
Resize
Rotate
Flip
Montage
Optimize
StillVideo
EOF
)
    case "${res}" in
        Convert)
            printf "Converted files will be in \"./converted\" directory.\n"
            printf "Converting multiple images to a video slideshow or gif is also possible.\n"
            printf "Specify the new file type by extension: "
            read ext
            if [[ -n "${ext}" ]]; then
                if [[ ! -d "converted" ]]; then
                    mkdir "converted"
                fi
                if [[ "${ext}" == 'gif' ]]; then
                    printf "Enter the delay amount (Default is 80): "
                    read delay
                    if [[ ! "${delay}" -gt 0 ]]; then
                        delay=80
                    fi
                    cmd="gm convert -loop 10 -delay ${delay} $(echo $(wrap-with-quotes "${fx}")) converted/output.gif"
                    bash -c "${cmd}"
                elif [[ "${ext}" == 'avif' ]]; then
                    # imagemagick mogrify and convert commands suck cpu and memory with jpeg images
                    # printf "${fx}" | xargs --delimiter='\n' mogrify -format avif -quality 90 -auto-orient -path ./converted
                    count=$(printf "${fx}\n" | wc -l)

                    while read item; do
                        count=$((count - 1))
                        filename="$(basename "${item}")"
                        printf "Processing ${item}: "

                        if [[ ! "${filename}" =~ \.(jp[e]?g|png)$ ]]; then
                            echo "${filename}: Input must be either png or jpg for avif conversion."
                            continue
                        fi

                        avifenc -j all -a cq-level=23 \
                          --min 0 --max 63 --minalpha 0 --maxalpha 63 \
                          -a end-usage=q -a tune=ssim \
                          "${item}" "converted/${filename%.*}.avif" &> /dev/null

                        if [[ $count -gt 0 ]]; then
                            printf "DONE - remaining ${count}.\n"
                        else
                            printf "FINISHED.\n"
                        fi
                    done < <(printf "${fx}\n")
                    if [[ -d "converted" ]]; then
                        lf -remote "send $id select converted"
                    fi
                elif [[ "${ext}" == 'mp4' ]]; then
                    printf "Enter the delay amount (Default is 1 second): "
                    read delay
                    if [[ ! "${delay}" -gt 0 ]]; then
                        delay=1
                    fi

                    if [[ -c /dev/dri/renderD128 ]]; then
                        cmd="cat $(echo $(wrap-with-quotes "${fx}")) | \
                        ffmpeg -vaapi_device /dev/dri/renderD128  \
                        -r "1/${delay}" -f image2pipe -i - -c:v h264_vaapi \
                        -vf 'format=nv12,hwupload,fps=25' -pix_fmt yuv420p -y converted/output.mp4"
                    else
                        cmd="cat $(echo $(wrap-with-quotes "${fx}")) | ffmpeg -r "1/${delay}" -f image2pipe -i - -c:v libx264 -vf fps=25 -pix_fmt yuv420p -y converted/output.mp4"
                    fi

                    bash -c "${cmd}"
                else
                    cmds=""
                    while IFS=$'\n' read item; do
                        fname="$(basename "${item}")"
                        cmds+="gm convert -define webp:lossless -quality 100 -auto-orient \"${fname}\" \"converted/${fname%.*}.${ext}\"\n"
                    done < <(printf "${fx}\n")
                fi

                printf "${cmds}" | parallel

                if [[ -d "converted" ]]; then
                    lf -remote "send $id select converted"
                fi
            fi
            ;;
        Resize)
            printf  "Resized files will be in \"./resized\" directory.\n"
            action=$(printf "Manually enter the new size\nResize max size to N px" | $FZF)
            case "$action" in
                Manually*)
                    printf "%s" "Specify the new dimensions in the format [Width]x[Height] or Amount%: "
                    read dim
                    if [[ "${dim}" =~ [0-9]*?x[0-9]*? ]] || [[ "${dim}" =~ [0-9]*% ]]; then
                        if [[ ! -d "resized" ]]; then
                            mkdir "resized"
                        fi
                        cmd=""
                        while IFS=$'\n' read item; do
                            fname="$(basename "${item}")"
                            ext="${fname##*.}"
                            if [[ "${dim}" =~ [0-9]*% ]]; then
                                dimpercent="${dim%\%}percent"
                            fi
                            newfname="${fname%.*}_${dimpercent:=$dim}.${ext}"
                            cmds+="gm convert -define webp:lossless,jpeg:preserve-settings -quality 100 -auto-orient -resize \"${dim}%\" \"${fname}\" \"resized/${newfname}\"\n"
                        done < <(printf "${fx}\n")

                        printf "${cmds}" | parallel

                        if [[ -d "resized" ]]; then
                            lf -remote "send $id select resized"
                        fi
                    else
                        printf "Entered dimension format is wrong.\n"
                    fi
                    ;;
                Resize*)
                    printf "Enter the max size in px: "
                    read size

                    if [[ $size -gt 0 ]]; then
                        if [[ ! -d "resized" ]]; then
                            mkdir "resized"
                        fi

                        cmd=""
                        while IFS=$'\n' read item; do
                            fname="$(basename "${item}")"
                            ext="${fname##*.}"

                            cmds+="gm convert -define webp:lossless,jpeg:preserve-settings -quality 100  -auto-orient -geometry ${size}\> \"${item}\" \"resized/${fname%.*}_${size}.${ext}\"\n"
                        done < <(printf "${fx}\n")

                        printf "${cmds}" | parallel

                        if [[ -d "resized" ]]; then
                            lf -remote "send $id select resized"
                        fi
                    fi
                    ;;
                *)
                    printf "Unknown action.\n"
                    exit
            esac
            ;;
        Rotate)
            printf "Enter the rotation amount (Use '-' for counter-clockwise rotation): "
            read rot
            if [[ "${rot}" =~ -?[0-9]+ ]]; then
                if [[ ! -d "rotated" ]]; then
                    mkdir "rotated"
                fi

                cmds=""
                while IFS=$'\n' read item; do
                    fname="$(basename "${item}")"
                    ext="${fname##*.}"
                    cmds+="gm convert -define webp:lossless,jpeg:preserve-settings -quality 100  -auto-orient -rotate \"${rot}\" \"${fname}\" \"rotated/${fname}\"\n"
                done < <(printf "${fx}\n")

                printf "${cmds}" | parallel

                if [[ -d "rotated" ]]; then
                    lf -remote "send $id select rotated"
                fi
            else
                printf "Entered rotation format is wrong.\n"
            fi
            ;;
        Flip)
            direction=$(printf "Horizontal\nVertical" | $FZF)

            if [[ "${direction}" == "Vertical" ]]; then
                direction="flip"
            elif [[ "${direction}" == "Horizontal" ]]; then
                direction="flop"
            else
                lf -remote "send $id echoerr Unsupported direction specifier!"
                exit
            fi

            if [[ ! -d "flipped" ]]; then
                mkdir "flipped"
            fi

            cmds=""
            while IFS=$'\n' read item; do
                fname="$(basename "${item}")"
                cmds+="gm convert -define webp:lossless,jpeg:preserve-settings -quality 100  -auto-orient -${direction} \"${fname}\" \"flipped/${fname}\"\n"
            done < <(printf "${fx}\n")

            printf "${cmds}" | parallel

            if [[ -d "flipped" ]]; then
                lf -remote "send $id select flipped"
            fi
            ;;
        Montage)
            cmd="gm montage -quality 100 +frame +shadow +label -geometry +0+0 $(echo $(wrap-with-quotes "${fx}")) montage.jpg"
            bash -c "${cmd}"
            if [[ -f 'montage.jpg' ]]; then
                lf -remote "send $id select montage.jpg"
                lf -remote "send $id unselect"
            fi
            ;;
        Optimize)
            if [[ ! -d optimized ]]; then
                mkdir optimized
            fi

            images=$(printf "${fx}" | grep -E '.(jpg|jpeg|png|webp|gif|svg)$')

            if [[ -n "${images}" ]]; then
                cmds=""
                while IFS=$'\n' read item; do
                    if [[ "${item##*.}" == 'jpg' ]] || [[ "${item##*.}" == 'jpeg' ]]; then
                        cmds+="jpegoptim --force -m80 --strip-exif -d optimized \"${item}\"\n"
                    fi

                    if [[ "${item##*.}" == 'png' ]]; then
                        cmds+="pngquant --verbose -f --ext '_new.png' --skip-if-larger --strip --quality 70-95 \"${item}\"\n"
                    fi

                    if [[ "${item##*.}" == 'webp' ]]; then
                        cmds+="cwebp -q 70 -o \"optimized/$(basename ${item})\" \"${item}\"\n"
                    fi

                    if [[ "${item##*.}" == 'gif' ]]; then
                        # TODO: Another alternative may be gifski
                        cmds+="gifsicle --optimize=3 --lossy=30 -o \"optimized/$(basename ${item})\" -i \"${item}\"\n"
                    fi

                    if [[ "${item##*.}" == 'svg' ]]; then
                        # cmds+="gifsicle --optimize=3 --lossy=30 -o \"optimized/$(basename ${item})\" -i \"${item}\"\n"
                        cmds+="svgo \"${item}\" -o \"optimized/$(basename ${item})\"\n"
                    fi
                done < <(printf "${fx}\n")
            fi

            printf "${cmds}" | parallel

            shopt -s nullglob
            for item in *_new.png; do
                mv "${item}" ./optimized;
            done
            ;;
        StillVideo)
            # TODO: 'Press any key to continue' interruption thing
            lf -remote "send $id image2video"
            ;;
        *)
            lf -remote "send $id echoerr Unknown action."
    esac
}}

# Info: Convert still image to a video
cmd image2video ${{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
    fi

    clear
    if [[ ! "${@}" -gt 0 ]]; then
        printf "Enter the video length in seconds: "
        read length
    else
        # TODO: check the input is a number
        length="${@}"
    fi

    if [[ "${length}" -gt 0 ]]; then
        count=$(printf "${fx}\n" | wc -l)
        encoder=$(printf "h264_vaapi\nlibx264" | $FZF)

        case "${encoder}" in
            libx264)
            while read item; do
                count=$((count - 1))
                filename="$(basename "${item}")"
                printf "Processing ${item}: "
                ffmpeg -nostdin -loglevel panic -hide_banner -loop 1 \
                    -i "${item}" \
                    -c:v libx264 \
                    -t "${length}" -pix_fmt yuv420p \
                    -vf 'scale=ceil(iw/2)*2:ceil(ih/2)*2' "${filename%.*}_libx264.mp4" -y

                if [[ $count -gt 0 ]]; then
                    printf "DONE - remaining ${count}.\n"
                else
                    printf "FINISHED.\n"
                fi
            done < <(printf "${fx}\n")
            ;;
            h264_vaapi)
                if [[ ! -c /dev/dri/renderD128 ]]; then
                    lf -remote "send $id echoerr '/dev/dri/renderD128 vaapi device does not exist!'"
                    exit
                fi
                while read item; do
                    count=$((count - 1))
                    filename="$(basename "${item}")"
                    printf "Processing ${item}: "
                    ffmpeg -nostdin -hide_banner -loglevel panic -loop 1 \
                        -i "${item}" \
                        -vaapi_device /dev/dri/renderD128 \
                        -c:v h264_vaapi \
                        -shortest -t "${length}" \
                        -vf 'format=nv12,hwupload' \
                        "${filename%.*}_vaapi.mp4" -y

                        if [[ $count -gt 0 ]]; then
                            printf "DONE - remaining ${count}.\n"
                        else
                            printf "FINISHED.\n"
                        fi
                done < <(printf "${fx}\n")
                ;;
            *)
                printf "Unknown encoder!"
                exit
        esac
    fi
}}

# Info: Crop black areas from videos
cmd crop-video !{{
    crop-video.sh ${fx}
}}

# Info: Encode video using x264 fast preset or av1
cmd optimize-video !{{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
        exit
    fi

    clear

    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d optimized ]]; then
        mkdir optimized
    fi

    encoder=$(printf "h264_vaapi\nav1" | $FZF)

    case "${encoder}" in
    av1)
        while read item; do
            count=$((count - 1))
                filename="$(basename "${item}")"
                printf "Processing ${item}: "

                # TODO: add vaapi version for av1
                SVT_LOG=1 ffmpeg -nostdin -loglevel panic -hide_banner \
                -i "${item}" -map_metadata -1 -c:a libopus -c:v libsvtav1 -qp 30 \
                -tile-columns 2 -tile-rows 2 -pix_fmt yuv420p -movflags +faststart -vf \
                "scale=trunc(iw/2)*2:trunc(ih/2)*2" -y "optimized/${filename%.*}_av1.mp4"

                if [[ $count -gt 0 ]]; then
                    printf "DONE - remaining ${count}.\n"
                else
                    printf "FINISHED.\n"
                fi
        done < <(printf "${fx}\n")
        ;;
    h264_vaapi)
        bitrate=$(printf "Copy from input\nEnter manually..." | $FZF --prompt="Enter the bitrate: ")

        if [[ $bitrate == "Enter manually..." ]]; then
            printf "Enter the bitrate in kb (e.g 3000): "
            read bitrate
        else
            copy=1
        fi
        while read item; do
            count=$((count - 1))
                filename="$(basename "${item}")"
                printf "Processing ${item}: "

                if [[ ! -c /dev/dri/renderD128 ]]; then
                  printf "/dev/dri/renderD128 for vaapi does not exist.\n"
                  exit
                fi

                if [[ $copy == 1 ]]; then
                  bitrate=$(($(mediainfo --Output="Video;%BitRate%" "${item}")/1000))
                  if ! [[ $bitrate =~ ^[0-9]+$ ]]; then
                    echo "Couldnot get bitrate of ${item}"
                    continue
                  fi
                fi

                # -preset defines the compression amount and speed
                # What you are probably more interested in is -b:v (bitrate)
                ffmpeg -nostdin -loglevel panic -hide_banner \
                -i "${item}" \
                -vaapi_device /dev/dri/renderD128 \
                -c:v h264_vaapi \
                -b:v "${bitrate}"k \
                -vsync vfr -preset fast -crf 23 \
                -c:a aac -b:a 128k \
                -vf 'format=nv12,hwupload' \
                -movflags +faststart -c:a copy \
                -y "optimized/${filename%.*}_h264.mp4"

                if [[ $count -gt 0 ]]; then
                    printf "DONE - remaining ${count}.\n"
                else
                    printf "FINISHED.\n"
                        fi
                        done < <(printf "${fx}\n")
                        ;;
    *)
        printf "Unknown encoder!"
        exit
        esac

    if [[ -d "optimized" ]]; then
        lf -remote "send $id select \"optimized\""
    fi
}}
#
# Info: Rotate video using ffmpeg
cmd rotate-video !{{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
        exit
    fi

    clear

    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d rotated ]]; then
        mkdir rotated
    fi

    direction=$(
cat <<EOF | $FZF | cut -d" " -f1
0 - 90° counterclockwise and vertical flip (default)
1 - 90° clockwise
2 - 90° counterclockwise
3 - 90° clockwise and vertical flip
EOF
)

    while read item; do
      count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Rotating ${item}: "

        # TODO: This version re-encodes with smaller file size.
        if [[ -c /dev/dri/renderD128 ]]; then
            ffmpeg -nostdin -loglevel panic -hide_banner \
                -i "${item}" \
                -vaapi_device /dev/dri/renderD128 \
                -c:v h264_vaapi \
                -vf "format=nv12,transpose=${direction},hwupload" \
                -c:a copy -y "rotated/${filename%.*}.mp4"
        else
            ffmpeg -nostdin -loglevel panic -hide_banner \
                -i "${item}" -c:v libx264  \
                -vf "transpose=${direction}" -c:a copy -y "rotated/${filename%.*}.mp4"
        fi


        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

    if [[ -d "rotated" ]]; then
        lf -remote "send $id select \"rotated\""
    fi
}}

# Info: Convert video to mp4 ( applies re-encoding )
cmd convert-video-to-mp4 !{{
    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d converted ]]; then
        mkdir converted
    fi

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Processing ${item}: "

        if [[ ! -c /dev/dri/renderD128 ]]; then
          printf "/dev/dri/renderD128 for vaapi does not exist.\n"
          exit
        fi

        # NOTE: Below is commented, because it will not work, for example, when
        # converting webm to mp4.
        # ffmpeg -nostdin -loglevel panic -hide_banner \
        #     -i "${item}" -codec copy -map 0 \
        #     "converted/${filename%.*}.mp4"

        ffmpeg -nostdin -loglevel panic -hide_banner \
            -i "${item}" \
            -vaapi_device /dev/dri/renderD128 \
            -c:v h264_vaapi \
            -preset slow -crf 22 \
            -c:a aac -b:a 128k \
            -vf 'format=nv12,hwupload' \
            "converted/${filename%.*}.mp4"

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

    if [[ -d "converted" ]]; then
        lf -remote "send $id select \"converted\""
    fi
}}

# Info: Reverse video
cmd reverse-video !{{
    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d reversed ]]; then
        mkdir reversed
    fi

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Reversing ${item}: "

        ffmpeg -nostdin -loglevel panic -hide_banner \
            -i "${item}" \
            -vaapi_device /dev/dri/renderD128 \
            -c:v h264_vaapi \
            -vsync vfr -preset fast -crf 23 \
            -vf 'reverse,format=nv12,hwupload' \
            -movflags +faststart \
            -y "reversed/${filename%.*}_h264.mp4"

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

    if [[ -d "reversed" ]]; then
        lf -remote "send $id select \"reversed\""
    fi
}}

# Info: Loop video N more times
cmd loop-video !{{
    clear
    printf "Enter the additional # of loops: "
    read loop

    if ! [[ $loop =~ ^[0-9]+$ ]]; then
      echo "Error: Not a number"
      exit
    fi

    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d loops ]]; then
        mkdir loops
    fi

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Looping ${item}: "

        ffmpeg -nostdin -loglevel panic -hide_banner \
            -stream_loop "${loop}" -i "${item}" -c copy \
            "loops/${filename}"

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

    if [[ -d "loops" ]]; then
        lf -remote "send $id select \"loops\""
    fi
}}

# Info: Convert audio to mp3
cmd convert-audio-to-mp3 !{{
    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d converted ]]; then
        mkdir converted
    fi

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Processing ${item}: "

        ffmpeg -nostdin -loglevel panic -hide_banner \
            -i "${item}" -b:a 192k -y \
            "converted/${filename%.*}.mp3"

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

    if [[ -d "converted" ]]; then
        lf -remote "send $id select \"converted\""
    fi
}}

# Info: Normalize mp3 gain (will replace original files!)
cmd normalize-mp3-gain !{{
    clear
    count=$(printf "${fx}\n" | wc -l)

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Processing ${item}: "

        mp3gain -q -r "${item}"

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

}}

# Info: Resize video using ffmpeg
cmd resize-video !{{
    printf "Non power of 2 resolutions may error!\n"
    printf "Supported formats:\n"
    printf "    * 640:480\n"
    printf "    * 640:-1 or -1:480 Use -1 for keeping the aspect for width or height\n"
    printf "Enter the new resolution: "
    read format

    # TODO check the format
    # TODO Convert to power of two when using -1

    bname=$(basename "${f}")
    count=$(printf "${fx}\n" | wc -l)

    if [[ ! -d resized ]]; then
        mkdir resized
    fi

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Processing ${item}: "

        # TODO: use vaapi if available
        ffmpeg -nostdin -loglevel panic -hide_banner \
            -i "${item}" -c:v libx264 \
            -vsync vfr -vf scale="${format}" \
            -movflags +faststart -c:a copy \
            "resized/${filename%.*}.mp4"
            # -vsync vfr -preset fast \

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")

    if [[ -d "resized" ]]; then
        lf -remote "send $id select \"resized\""
    fi
}}

# Info: Display media information in status bar
cmd mediainfo %{{
    mime=$(mimetype --output-format '%d' "${f}")

    if [[ "${mime}" =~ image$ ]]; then
        info=$(gm identify "$(basename "${f}")")
    elif [[ "${mime}" =~ video$ ]]; then
        info=$(mediainfo --Inform="Summary" "${f}")
    elif [[ "${mime}" =~ audio$ ]]; then
        info=$(mediainfo --Inform="Summary" "${f}")
    elif [[ "${f}" =~ \.avif$ ]]; then
        # mimetype cannot handle avif
        info=$(mediainfo --Inform="Summary" "${f}")
    else
        lf -remote "send $id echoerr Not a media file!"
        exit
    fi

    printf "${info}"
}}
map gm :mediainfo

# Info: Convert markdown to pdf using pandoc
cmd md2pdf !{{
    pandoc --pdf-engine=lualatex \
        -H "${HOME}/Documents/notes/head.tex" \
        --highlight-style zenburn -s "${f}" -o "${f}".pdf

    if [[ -f "${f}".pdf ]]; then
        lf -remote "send $id select \"${f}.pdf\""
    fi
}}

# Info: Convert markdown to pdf using pandoc with groff as PDF engine
cmd md2pdf-groff !{{
    pandoc --pdf-engine=pdfroff \
        --toc-depth=1 \
        --highlight-style zenburn "${f}" -o "${f}".pdf

    if [[ -f "${f}".pdf ]]; then
        lf -remote "send $id select \"${f}.pdf\""
    fi
}}

# Display a command palette
# Every cmd must have an information line.
# Every cmd description must be in this format:
# "# Info: Description goes here..."
# "cmd cmd_name &{{ }}"
# If you want to create a cmd that should not be listed,
# create it like this (without quotes):
# "# Info: Noop>cmd_name"
# "cmd_name ${{}}"
# TODO: This is VERY fragile.
map gp ${{
    FZF=$(command -v fzf)

    if [[ -f "/tmp/lf_cmd_palette_cache" ]] && [[ "/tmp/lf_cmd_palette_cache" -ot "${HOME}/.config/lf/lfrc" ]]; then
        rm "/tmp/lf_cmd_palette_cache"
    fi

    if [[ -f /tmp/lf_cmd_palette_cache ]]; then
        action=$(cat /tmp/lf_cmd_palette_cache | $FZF)
    else
        cmds=$(grep -E ^cmd "${HOME}/.config/lf/lfrc" | cut -d' ' -f2)
        infos=$(grep -E '^# Info:' "${HOME}/.config/lf/lfrc" | cut -d' ' -f3-)
        noops=$(echo "$infos" | grep "Noop" | cut -d'>' -f2)
        infos=$(echo "$infos" | grep -v "Noop")
        # TODO: Improve this ugliness
        cmds=$(
                while IFS=$'\n' read item; do
                    echo "$cmds" | grep -v "${item}"
                done < <(printf "${noops}\n")
        )
        c1=$(printf "$cmds" | wc -l)
        c2=$(printf "$infos" | wc -l)
        if [[ $c1 == $c2 ]]; then
            action=$(paste -d':' <(printf "${cmds}") <(printf "${infos}") | column -t -s':' | sort | tee /tmp/lf_cmd_palette_cache | $FZF)
        else
            lf -remote "send $id echoerr Info strings do not match the count of cmds."
            exit
        fi
    fi

    if [[ -n "${action}" ]]; then
        lf -remote "send $id push :${action%%\ *}<space>"
    fi

}}

# Info: Add hc_ to the selected filenames
cmd hc &{{
    # printf '%s' "${fx}" | xargs --delimiter='\n' -I '{}' basename '{}' | xargs --delimiter='\n' -I '{}' mv '{}' hc_'{}'
    # Let's apply some PERL
    # printf '%s' "${fx}" | perl -wnlaF'/' -e 'use File::Copy ('move'); move $F[-1], "hc_$F[-1]" or die "Move failed: $!";'
    printf '%s' "${fx}" | perl -wnlaF'/' -e 'rename $F[-1], "hc_$F[-1]" or die "Rename failed: $!";'
    lf -remote "send $id reload"
}}
map hc :hc

# Info: Rename files with random strings
cmd rename-random &{{
    # Random string: https://stackoverflow.com/a/10336772/4195200
    printf '%s' "${fx}" | perl -wnlaF'/' \
        -e '@arr = split /\./, $F[-1];
            $rand = sprintf("%010X", rand(0xFFFFFFFF));
            rename $F[-1], "$rand.$arr[1]" or die "Rename failed: $!";'
    lf -remote "send $id reload"
}}

# Info: Go to the original file of symlink
cmd follow-symlink &{{
    real=$(realpath "${f}")
    lf -remote "send $id select ${real}"
}}

# Info: Extract audio from video as uncompressed wav
cmd extract-audio !{{
    while IFS=$'\n' read item; do
        channels=$(mediainfo --Inform="Audio;%Channels%" "${item}")
        base=$(basename "$item")

        if [[ "${channels}" -gt 0 ]]; then
            ffmpeg -i "${item}" -vn -acodec pcm_s16le -ar 44100 -ac "${channels}" "${base%.*}.wav"
        else
            continue
        fi
    done < <(printf "${fx}\n")
}}

# Info: Create a new kitty shell window with cwd <gn>
cmd new-kitty-window &{{
    kitty @ --to unix:/tmp/mykitty launch --type window --cwd "${PWD}"
}}
map gn :new-kitty-window

# Info: Convert mp4 to animated avif
cmd mp4-to-avif !{{
    echo 'Converted videos will be in "./converted" directory.'
    echo 'Warning: AVIF conversion can take some time depending on the input video!'
    if [[ ! -d './converted' ]]; then
        mkdir './converted'
    fi
    count=$(printf "${fx}\n" | wc -l)

    while read item; do
        count=$((count - 1))
        filename="$(basename "${item}")"
        printf "Processing ${item}: "

        ffmpeg -nostdin -loglevel panic -hide_banner -i "${item}" -pix_fmt yuv420p -f yuv4mpegpipe output.y4m

        avifenc -j all -a cq-level=23 \
        --min 0 --max 63 --minalpha 0 --maxalpha 63 \
        -a end-usage=q -a tune=ssim \
        output.y4m "converted/${filename%.*}.avif" &> /dev/null

        if [[ -f './output.y4m' ]]; then
            rm -f './output.y4m'
        fi

        if [[ $count -gt 0 ]]; then
            printf "DONE - remaining ${count}.\n"
        else
            printf "FINISHED.\n"
        fi
    done < <(printf "${fx}\n")
    if [[ -d "converted" ]]; then
        lf -remote "send $id select converted"
    fi
}}

# Info: Calculate total number of lines of selected file(s)
cmd total-line-number &{{
    output=$(total_line_numbers.php $fx)
    lf -remote "send $id echo ${output}"
}}

# Info: Count number of sub files and directories under selected directory
cmd count &{{
    if [[ -d "${f}" ]]; then
        # Count is a symlink to PHP script in ~/bin
        lf -remote "send $id echo Calculating..."
        DIRS=""
        while IFS=$'\n' read item; do
            DIRS="${DIRS} '${item}'"
        done < <(printf "${fx}\n")
        output=$(bash -c "count ${DIRS}")
        lf -remote "send $id echo ${output}"
    fi
}}

# Info: Fuzzy search in command history
cmd hist ${{
    clear
    cmd=$(
            lf -remote "query $id history" |
            awk -F'\t' 'NR > 1 { print $NF}' |
            sort -u |
            fzf --prompt='Execute command: '
         )
    lf -remote "send $id $cmd"
}}

# Info: Mount Android phone through mtp
cmd mount-mtp &{{
    GOMTPFS=$(command -v go-mtpfs)
    if [[ -z "${GOMTPFS}" ]]; then
        lf -remote "send $id echoerr 'go-mtpfs binary is not accessible!'"
        exit
    fi

    if [[ ! -d "~/mtp" ]]; then
        mkdir ~/mtp || lf -remote "send $id echoerr 'Mount point ~/mtp could not be created!'"
    fi

    "${GOMTPFS}" ~/mtp &
    if [[ $? == 0 ]]; then
        lf -remote "send $id select ~/mtp"
    else
        lf -remote "send $id echoerr 'Phone could not be mounted! Check mtp is enabled and the phone is unlocked.'"
    fi
    exit
}}

# Info: Unmount Android phone connected with mtp
cmd umount-mtp &{{
    if [[ -d ~/mtp ]]; then
        lf -remote "send $id :cd ~"
        fusermount -u ~/mtp
        if [[ $? != 0 ]]; then
            lf -remote "send $id echoerr 'Unmount error!. Probably not mounted or currently in use.'"
            exit
        fi
        lf -remote "send $id echo 'Phone succesfully unmounted!'"
    fi
}}

# Info: Split video by duration
cmd split-video-by-duration !{{
    # FIXME: Output durations may all be different.
    clear
    read -rp "Enter the duration in MM::SS format (default: 00:11): " duration

    # TODO: check the format
    if [[ -z "${duration}" ]]; then
        duration="00:11"
    fi

    while IFS=$'\n' read item; do
        mime=$(mimetype --output-format '%m' "${item}")

        if [[ "${mime}" =~ video ]]; then
            BASENAME=$(basename "${item}")
            NAME="${BASENAME%.*}"
            EXT="${BASENAME##*.}"
            printf "Splitting ${item}\n"
            ffmpeg -nostdin -loglevel panic -hide_banner -i "${item}" \
                -threads "$(nproc)" -vcodec copy \
                -f segment -segment_time "${duration}" \
                -reset_timestamps 1 "${NAME}"_%02d."${EXT}"
        fi
    done < <(printf "${fx}\n")
}}

# Info: Sync container iso to its backup counterpart
cmd sync-isos !{{
    clear
    while IFS=$'\n' read item; do
        sync-isos2 "${item}"
    done < <(printf "${fx}\n")
}}

# Info: Convert audio to another format
cmd convert-audio !{{
    clear
    base="$(basename "${f}")"
    read -rp "Enter the extension: " ans
    output="${base%.*}.${ans}"
    printf "Converting...\n"
    ffmpeg -loglevel panic -hide_banner -i "${f}" "${output}"
    if [[ -f "${output}" ]]; then
        lf -remote "send $id select \"${output}\""
        lf -remote "send $id echo Successfully converted!."
    else
        lf -remote "send $id echoerr Conversion could not be done!."
    fi
    printf "Done!\n"
}}

# Info: View markdown in a new terminal split using glow
cmd markdown-view &{{
    kitty @ --to unix:/tmp/mykitty launch --cwd "${PWD}" \
        --self /usr/bin/glow "${f}" --pager
}}

# Info: Open selected file with $EDITOR (usually, vim)
# cmd open-with-vim &{{$EDITOR "$f" && go2vim}}
cmd open-with-vim &{{
  while IFS=$'\n' read item; do
    $(which nvim) --noplugin \
      --cmd "lua vim.fn.rpcrequest(vim.fn.sockconnect('pipe', '/home/sagirbas/.cache/nvim/server.pipe', { rpc = true }), 'nvim_command', ':e! ${item}')" \
      --cmd "q" --headless
  done < <(printf "${fx}\n")
  go2vim
}}
map e open-with-vim

# Info: Add current working directory to autojump database
cmd add-to-autojump &{{
  autojump --add "${PWD}"
}}

# Info: Compress selected files(s) for WEB with gzip or brotli
cmd compress !{{
    FZF=$(command -v fzf)
    if [[ -z $FZF ]]; then
        lf -remote "send $id echoerr fzf is not installed."
        exit
    fi

    clear
    echo "If the compressed file is larger than the original, it will be deleted."

    compressor=$(printf "brotli\ngzip" | $FZF)

    case "${compressor}" in
    brotli)
        while read item; do
            brotli -q 10 -f "${item}" --squash --output="${item}.br"
        done < <(printf "${fx}\n")
        ;;
    gzip)
        while read item; do
            gzip -9f "${item}" --keep

            # Delete if larger than the original
            if [[ -f "${item}.gz" ]]; then
                size_org="$(stat ${item} --format=%s)"
                size_comp="$(stat ${item}.gz --format=%s)"

                if [ $size_comp -gt $size_org ]; then
                    rm -f "${item}.gz"
                fi
            fi
        done < <(printf "${fx}\n")
        ;;
    *)
        printf "Cancelled!\n"
        exit
        esac

}}

# Info: Annotate images with spectacle or satty
cmd annotate-image &{{
    TOOL=""
    for cmd in spectacle satty; do
      if command -v "$cmd" &> /dev/null; then
        if [[ "${cmd}" == 'spectacle' ]]; then
          TOOL="${cmd} --edit-existing"
          break
        elif [[ "${cmd}" == 'satty' ]]; then
          TOOL="${cmd} --fullscreen --filename"
          break
        fi
      fi
    done

    if [[ -z "${TOOL}" ]]; then
        lf -remote "send $id echoerr This command requires spectacle or satty."
        exit
    fi

    mime=$(file --brief --mime "${f}")
    if [[ $mime =~ ^image ]]; then
      ${TOOL} "${f}"
      exit 0
    else lf -remote "send $id echoerr Input file is not recognized as image."
      exit
    fi



}}

# Info: Extract text from image using tesseract-ocr
cmd ocr &{{
  if command -v tesseract &> /dev/null; then
    tesseract "${f}" stdout -l eng | xclip -selection clipboard
      if [[ $? == 0 ]]; then
          lf -remote "send $id echo Extracted text copied to clipboard."
      else
          lf -remote "send $id echoerr Scanning failed!."
      fi
    else
      lf -remote "send $id echoerr tesseract-ocr is not installed!"
  fi
}}


# Info: Install the selected debian package
cmd install-deb &{{
  mime=$(file --brief "${f}")
  if [[ $mime =~ "Debian binary package" ]]; then
    kitty @ --to unix:/tmp/mykitty launch \
        --type window --hold \
        --cwd "${PWD}" \
        bash --noprofile --norc -c "sudo dpkg -i "${f}""
  else
    lf -remote "send $id echoerr Not a Debian package!"
  fi
}}

# Info: Rename mp4 files
cmd rename-mp4 &{{
    if [[ -z "$@" ]]; then
        lf -remote "send $id echoerr No start number provided!"
        exit
    fi

    wrap-with-quotes "${fx}" | xargs -I '{}' rename-mp4 -c "$1" "{}"
}}
